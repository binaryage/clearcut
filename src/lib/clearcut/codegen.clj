(ns clearcut.codegen
  "Helpers for generating code for core macros.
  The generated code greatly depends on effective clearcut configuration (see defaults.clj).
  e.g. diagnostics, debugging and other settings."
  (:refer-clojure :exclude [gensym])
  (:require [clearcut.config :as config]
            [clearcut.helpers :refer [gensym]]
            [clearcut.schema :as schema]
            [clearcut.debug :refer [log debug-assert]]
            [clearcut.constants :as constants]
            [clearcut.helpers :as helpers]
            [clearcut.clojure]
            [clearcut.state :as state]
            [clearcut.compiler :as compiler]
            [clearcut.sdefs :as sdefs]
            [clojure.spec.alpha :as s]
            [clearcut.compiler :as compiler :refer [with-compiler-context!]]
            [clearcut.cljs :as cljs]))

; -- helpers ----------------------------------------------------------------------------------------------------------------

(defn cljs? []
  (helpers/cljs? state/*invocation-env*))

(defn elide-log-level? [level]
  (debug-assert (contains? constants/all-levels level))
  (contains? (config/elided-log-levels) level))

(defn level-to-method [level]
  (condp = level
    constants/level-fatal 'js/console.error
    constants/level-error 'js/console.error
    constants/level-warn 'js/console.warn
    constants/level-info 'js/console.info
    constants/level-debug 'js/console.log
    constants/level-trace 'js/console.log))

; -- helper code generators -------------------------------------------------------------------------------------------------

(defn gen-debug-runtime-state-consistency-check [body]
  (if-not (config/debug?)
    body
    (let [captured-runtime-state-sym (gensym "captured-runtime-state")
          result-sym (gensym "result")]
      ; we don't want body to change *runtime-state* without restoring
      ; this could theoretically happen with code-rewriting when using go-macros
      `(let [~captured-runtime-state-sym clearcut.state/*runtime-state*
             ~result-sym ~body]
         (assert (identical? ~captured-runtime-state-sym clearcut.state/*runtime-state*))
         ~result-sym))))

; this method is hand-written to reduce space (it will be emitted on each macro call-site)
; also to avoid busy-work generated by ClojureScript compiler handling varargs
(def console-reporter-template "function(){arguments[0].apply(console,Array.prototype.slice.call(arguments,1))}")

(defn gen-runtime-context-if-needed! [& body]
  (let [body-code `(do ~@body)]
    (if-not (config/diagnostics?)
      body-code
      (let [console-reporter (list 'js* console-reporter-template)
            call-site-error `(js/Error.)]
        ; it is imporant to keep console-reporter and call-site-error inline so we get proper call-site location / line number
        `(binding [clearcut.state/*runtime-state* (clearcut.state/prepare-state ~call-site-error ~console-reporter)]
           ~(gen-debug-runtime-state-consistency-check body-code))))))

; -- cljs code generation ---------------------------------------------------------------------------------------------------

(defn macroexpand-param-list [param-list]
  (map cljs/macroexpand param-list))

(defn macroexpand-param-list-if-needed [param-list]
  (if (config/macroexpand-params?)
    (macroexpand-param-list param-list)
    param-list))

(defn destructure-static-params [param-list]
  (let [expanded-params (macroexpand-param-list-if-needed param-list)
        destructured-params (s/conform :clearcut.sdefs/static-params expanded-params)]
    (if-not (s/invalid? destructured-params)
      destructured-params)))

(defn gen-static-log-call [method args]
  (if (config/diagnostics?)
    `((clearcut.state/get-console-reporter) ~method ~@args)
    `(~method ~@args)))

(defn gen-static-cljs-log [level destructured-params]
  (let [prepared-args (schema/prepare-log-args destructured-params)
        method (level-to-method level)]
    (gen-static-log-call method prepared-args)))

(defn gen-dynamic-cljs-log [level items]
  `(clearcut.core/log-dynamically ~level (cljs.core/array ~@items)))

(defn gen-variadic-cljs-log [level items-sym]
  (debug-assert (symbol? items-sym))
  `(clearcut.core/log-dynamically ~level (cljs.core/to-array ~items-sym)))

(defn gen-cljs-log [level items]
  (debug-assert (or (list? items) (symbol? items)))
  (gen-runtime-context-if-needed!
    (if (symbol? items)                                                                                                       ; items is a symbol in cljs when called with variadic args
      (gen-variadic-cljs-log level items)
      (if-let [destructured-params (destructure-static-params items)]
        (gen-static-cljs-log level destructured-params)
        (gen-dynamic-cljs-log level items)))))

; -- clj code generation ----------------------------------------------------------------------------------------------------

(defn gen-clj-log [level items]
  (debug-assert (list? items))
  ; TODO: ensure clojure.tools.logging here (at compile time)
  ; TOOD: we could do macro-expansion and compile-time validation of items
  `(clearcut.clojure/log ~'*ns* ~level ~@items))

; -- shared macro bodies ----------------------------------------------------------------------------------------------------

(defn gen-log [level items]
  (debug-assert (integer? level))
  (if-not (elide-log-level? level)
    (if (cljs?)
      (gen-cljs-log level items)
      (gen-clj-log level items))))

(defn gen-log-with-env [form env level items]
  (with-compiler-context! form env
    (gen-log level items)))
