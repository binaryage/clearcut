(ns clearcut.codegen
  "Helpers for generating code for core macros.
  The generated code greatly depends on effective clearcut configuration (see defaults.clj).
  e.g. diagnostics, debugging and other settings."
  (:refer-clojure :exclude [gensym])
  (:require [clearcut.config :as config]
            [clearcut.helpers :refer [gensym]]
            [clearcut.compiler :as compiler]
            [clearcut.debug :refer [log debug-assert]]
            [clearcut.constants :as constants]
            [clearcut.helpers :as helpers]
            [clearcut.clojure]
            [clearcut.state :as state]))

(defn cljs? []
  (helpers/cljs? state/*invocation-env*))

; -- helper code generators -------------------------------------------------------------------------------------------------

(defn gen-reported-message [msg]
  msg)

(defn gen-reported-data [data]
  `(let [data# ~data]
     (or (if (clearcut.config/use-envelope?)
           (if-let [devtools# (cljs.core/aget goog/global "devtools")]
             (if-let [toolbox# (cljs.core/aget devtools# "toolbox")]
               (if-let [envelope# (cljs.core/aget toolbox# "envelope")]
                 (if (cljs.core/fn? envelope#)
                   (envelope# data# "details"))))))
         data#)))

(defn gen-console-method [kind]
  (case kind
    :error `(aget js/console "error")
    :warning `(aget js/console "warn")))

(defn gen-report-runtime-message [kind msg data]
  (debug-assert (contains? #{:error :warning} kind))
  (let [mode (case kind
               :error `(clearcut.config/get-error-reporting)
               :warning `(clearcut.config/get-warning-reporting))]
    `(case ~mode
       :throw (throw (clearcut.state/prepare-error-from-call-site ~(gen-reported-message msg) ~(gen-reported-data data)))
       :console ((clearcut.state/get-console-reporter) ~(gen-console-method kind) ~(gen-reported-message msg) ~(gen-reported-data data))
       false nil)))

(defn gen-debug-runtime-state-consistency-check [body]
  (if-not (config/debug?)
    body
    (let [captured-runtime-state-sym (gensym "captured-runtime-state")
          result-sym (gensym "result")]
      ; we don't want body to change *runtime-state* without restoring
      ; this could theoretically happen with code-rewriting when using go-macros
      `(let [~captured-runtime-state-sym clearcut.state/*runtime-state*
             ~result-sym ~body]
         (assert (identical? ~captured-runtime-state-sym clearcut.state/*runtime-state*))
         ~result-sym))))

; this method is hand-written to reduce space (it will be emitted on each macro call-site)
; also to avoid busy-work generated by ClojureScript compiler handling varargs
(def console-reporter-template "function(){arguments[0].apply(console,Array.prototype.slice.call(arguments,1))}")

(defn gen-runtime-context! [& body]
  (let [body-code `(do ~@body)]
    (let [console-reporter (list 'js* console-reporter-template)
          call-site-error `(js/Error.)]
      ; it is imporant to keep console-reporter and call-site-error inline so we get proper call-site location and line number
      `(binding [clearcut.state/*runtime-state* (clearcut.state/prepare-state ~call-site-error ~console-reporter)]
         ~(gen-debug-runtime-state-consistency-check body-code)))))

(defn gen-supress-reporting? [msg-id]
  `(contains? (clearcut.config/get-suppress-reporting) ~msg-id))

(defn elide-log-level? [level]
  (debug-assert (contains? constants/all-levels level))
  (contains? (config/elided-log-levels) level))

; -- raw implementations ----------------------------------------------------------------------------------------------------

(defn gen-cljs-log-impl [level items]
  (let [items-array (if (symbol? items)
                      `(cljs.core/to-array ~items)
                      `(cljs.core/array ~@items))]
    `(clearcut.core/log-dynamically ~level ~items-array)))

(defn gen-clj-log-impl [level items]
  ; TODO: ensure clojure.tools.logging here (at compile time)
  `(clearcut.clojure/log ~'*ns* ~level ~@items))

; -- shared macro bodies ----------------------------------------------------------------------------------------------------

(defn gen-log [level items]
  (debug-assert (integer? level))
  (if-not (elide-log-level? level)
    (if (cljs?)
      (do
        (debug-assert (or (list? items) (symbol? items)))                                                                     ; items is a symbol in cljs when called with variadic args
        (gen-runtime-context!
          (gen-cljs-log-impl level items)))
      (do
        (debug-assert (list? items))
        (gen-clj-log-impl level items)))))
